\documentclass[a4paper, 14pt]{extarticle}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english, russian]{babel}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{verbatim}
\usepackage{indentfirst}

\usepackage{tikz}  
\usetikzlibrary{graphs}

\setcounter{secnumdepth}{0}
\setlength{\parindent}{30pt}

\begin{document}

\begin{titlepage}
  \begin{center}
    \vspace*{1cm}

    \Huge
    \textbf{Теория формальных языков. Рубежный контроль №1}

    \vspace{0.5cm}
    \Large
    Вариант №11

    \vspace{1.5cm}

    \textbf{Банников Арсений}

    \vfill

    \vspace{0.8cm}

    \Large
    Теоретическая информатика и компьютерные технологии\\
    МГТУ им. Н.Э. Баумана\\
    ноябрь 2023

  \end{center}
\end{titlepage}

\newpage

\tableofcontents

\newpage

\section{Задача 1}

Язык всех завершающихся систем переписывания строк из одного правила. Алфавит: $\{f,g,\to\}$

\subsection{Решение}
Докажем нерегулярность при помощи отрицания леммы о накачке для регулярных языков.
Рассмотрим слово $f^{n + 1} \to f^n$ , очевидно то что накачка не может содержать
символ $\to$, так как при положительной накачке количество таких символов увеличивается,
но оно должно оставаться равным одному. Следовательно накачку можно выбрать только
либо слева, либо справа от $\to$. При выборе накачки из фрагмента справа положительная
накачка выводит слово из языка, а при выборе накачки из левого фрагмента отрицательная
накачка выводит слово из языка.

Примеры накачек:
\[ f^{n_1}f^{i (n + 1 - n_1 - n_2)}f^{n_2} \to f^n \tag{1} \]

В такой накачке $n + 1 - n_1 - n_2 \ge 1 \Rightarrow n_1 + n_2 < n + 1$. Следовательно
при отрицательной накачке ($i = 0$) мы получим слово $f^{n_1 + n_2} \to f^n$. Полученное
слово не пренадлежит языку так как $n_1 + n_2 \le n$.

\[ f^{n + 1} \to f^{n_1}f^{i (n - n_1 - n_2)}f^{n_2} \tag{2} \]

Данное слово эквивалентно $f^{n + 1} \to f^{i (n - n_1 - n_2) + n_1 + n_2}$. Так как
длина накачки ненулевая, то $n - n_1 - n_2 \ge 1$. Взяв $i = n + 1$ получим
$(n + 1) (n - n_1 - n_2) \ge n \Rightarrow (n + 1) (n - n_1 - n_2) + n_1 + n_2 \ge n$.
А заначит полученное от положительной накачки слово не пренадлежит языку.

Мы рассмотрели все варианты накачки, а значит выбранное слово не накачивается, следовательно
язык не регулярен.

\newpage
\section{Задача 2}

Язык $\{a^\frac{n}{\log_{2} n}b^n\}$

\subsection{Решение}

\begin{comment}
Заметим что при достаточно больших $x$ значение выражения $\frac{x}{\log_2x}$ возрастает,
это означает, что при достаточно больших значениях выражения $\frac{x}{\log_2x}$ корень
этого выражения единственен. Теперь для некоторого $n$ возьмем $n_0$ такое, что $n_0 > n$
и слово $a^\frac{n_0}{\log_2n_0}b^{n_0}$ пренадлежит языку. Такое $n_0$ всегда существует,
так как $n_0 = 2^{2^p}, p \in \mathbb{N}$ порождает слово из языка и может быть сколь угодно
большим. Теперь попробуем выбрать накачку, очевидно что она состоит либо только из $a$, либо
только из $b$, если же она состоит из обоих символов, то положительная накачка выводит слово
из языка, так как появляется множество чередований $a$ и $b$, хотя должно быть ровно одно. 
Также заметим что по количеству символов $a$ мы можем однозначно определить количество символов
$b$ из-за однозначности корня выражения описанного ранее. Обратное также, очевидно, верно.
Значит достаточно большая положительная накачка выводит слово из языка, так как нарушается
соотношение количества символов. Так как накачка выводит слово из языка, то язык не регулярен.
\end{comment}

Заметим что область значений $n$ не равна $\mathbb{N}$, так как например при $n = 8$
степень при $a$ имеет нецелое значение. Найдем область допустимых значений $n$. Очевидно,
что $n \in \mathbb{N} \cap \{x \mid \frac{x}{\log_2x} \in \mathbb{N}\}$. Рассмотрим множество
$\{x \mid \frac{x}{\log_2x} \in \mathbb{N}\}$, в него входят только $x$ такие, что
$\log_{2}x \in \mathbb{N}$. Для доказательства последнего утверждения допустим, что
$\log_2x \in \mathbb{R}$, возможны два случая: либо $\log_2x \in \mathbb{I}$, либо
$\log_2x \in \mathbb{Q}$. Если $\log_2x \in \mathbb{I}$, то $\frac{x}{\log_2x} \in \mathbb{I}$,
но такое невозможно в силу правила построения множества. Если $\log_2x \in \mathbb{Q}$, то пусть
$\log_2x \notin \mathbb{N}$ что означает, что
$\log_2x = a + b, a \in \mathbb{N}, b \in (0;1) \cap \mathbb{Q}$. Заметим что
$x = 2^{\log_2x} = 2^a2^b$, но $2^a \in \mathbb{N}$, а $2^b \in \mathbb{I}$, из чего
следует, что $2^a2^b \in \mathbb{I}$, а значит и $x \in \mathbb{I}$, но так как
$x \in \mathbb{N}$, получили противоречие. Следовательно $x = 2^p, p \in \mathbb{N}$.

Получаем, что множество $\{x \mid \frac{x}{\log_2x} \in \mathbb{N}\}$
состоит из элементов вида $x = \frac{2^p}{p}, p \in \mathbb{N}$, следовательно
$2^p = 0 \pmod{p}$. Это значит, что $p = 2^m, m \in \mathbb{N}$. Следовательно
$n = 2^{2^m}, m \in \mathbb{N}$. Теперь заметим что при увеличении $m$ количество символов
$a$ растет медленнее чем количество символов $b$ (имеется в виду порядок роста). Но при
накачке (если первый накачиваемый фрагмент состоит только из символов $a$, а второй только
из символов $b$) рост количества букв у обеих частей линейный, следовательно в какой то момент
нарушится отношение количества символов. Если же рассматривать вариант разбиения такой, что
первый и второй фрагменты накачки состоят только из одинаковых букв, то очевидно что
положительная накачка разрушает соотношение количества букв.

Итак, ниодно слово языка (при достаточно больших $n$) не накачивается, а значит язык не является
КС

\newpage
\section{Задача 3}

Грамматика

\begin{align}
  &S \to SbbabSbaaabS \\
  &S \to SSbS \\
  &S \to a
\end{align}

\subsection{Решение}

Будем рассматривать только правила (2) и (3). Рассмотрим слово $a^{n + 1}(ba)^n$. Оно
получается раскрытием второго нетерминала по правилу (2), сентенциальные формы следующие:

\begin{center}
  \begin{tabular}{l}
    $S$ \\
    $SSbS$ \\
    $SSSbSbS$ \\
    $SSSSbSbSbS$ \\
    $...$
  \end{tabular}
\end{center}

Заметим, что если раскрывать только по второму и третьему правилу то количество букв то для
слова $\omega$ верно, что $|\omega|_a = 2m + 1$ и $|\omega|_b = m$.

Рассмотрим пересечение данной граматики с регулярным языком $a^*(ba)^*$. Раскрытие по правилу (1)
не лежит в пересечении из-за фрагмента $baaab$. Очевидно что мы должны выбирать такую накачку
$\omega_2$, что $|\omega_2|_a = 2m$ и $|\omega_2|_b = m$, но такой фрагмент может быть только
на границе фрагментов звездочных групп. Мы очевидно мы не можем выбрать такой фрагмент, так
как положительная накачка породит слово где справа от первой встретившейся $b$ будет
последовательность из $a$ длиной хотя бы 2, что не соответствует пересекаемому регулярному языку. 
Следовательно исходный язык не регулярен.

\newpage
\section{Задача 4}

Язык всех скобочных последовательностей, являющихся сдвигами слов из языка Дика
(скобки только круглые).

\subsection{Решение}

Исходный язык можно переписать как $\{ \omega \mid |\omega|_( = |\omega|_)\}$.
Это верно так как мы можем преобразовать любое слово такого языка к слову из языка Дика, и
для любого слова языка Дика мы можем получить перестановку с очевидно одинаковым числом 
открывающих и закрывающих скобок. Обсудим алгоритм преобразования перестановки слова к слову.
Алгоритм состоит в том чтобы находить первую неверно пославленную закрывающую скобку и весь
префикс, включая эту скобку, сдвигать в конец. Для доказательства корректности заметим
полуинвариант. Введем счетчик, изначально равный нулю, и будем уменьшать его на один каждый
раз если считываем закрывающую скобку и увеличивать если считываем открывающую. Полуинвариантом
является минимальное значение данного счетчика за полный проход по слову, которое каждый раз
будет увеличиваться. Очевидно что увеличиваться бесконечно оно не может, так как в конце разбора
слова счетчик всегда равен нулю. Заметим что переместив начальный неправильный префикс в конец
Мы увеличим полуинвариант на один. Это следует из того, что перемещая префикс без последней
закрывающей скобки мы не изменяем полуинвариант, так как префикс без последней скобки является
словом языка Дика. Теперь заметим, что если убрать закрывающую скобку, то мы увеличим
полуинвариант. После того как мы убрали закрывающую скобку из начала счетчик после прохода по
слову стал равным одному. Ну и очевидно, что добавив закрывающую скобку в конец полуинвариант
не уменьшится. Следовательно полуинвариант всегда увеличивается. Значит в какой то момент он
станет равным нулю, что означает что мы распознаем слово языка Дика. 

Теперь построим распознаватель, который следит за равенством количества скобок\dots

\end{document}
